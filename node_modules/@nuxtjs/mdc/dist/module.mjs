import { createResolver, extendViteConfig, defineNuxtModule, addTemplate, addComponent, addImports, addComponentsDir, addServerHandler } from '@nuxt/kit';
import fs from 'fs';
import { pascalCase } from 'scule';
import { defu } from 'defu';
import { pathToFileURL } from 'url';

const mdcImportTemplate = async ({ nuxt, options }) => {
  const resolver = createResolver(import.meta.url);
  const imports = [];
  const { imports: remarkImports, definitions: remarkDefinitions } = processUnistPlugins(options.remarkPlugins);
  const { imports: rehypeImports, definitions: rehypeDefinitions } = processUnistPlugins(options.rehypePlugins);
  let highlighter = "false";
  if (options.highlight) {
    highlighter = JSON.stringify(options.highlight);
    if (options.highlight.highlighter) {
      const path = await resolver.resolvePath(options.highlight.highlighter, { alias: nuxt.options.alias });
      imports.push(`import syntaxHighlighter from '${path}'`);
      highlighter = highlighter.replace(`"${options.highlight.highlighter}"`, "syntaxHighlighter");
    }
  }
  return [
    ...remarkImports,
    ...rehypeImports,
    ...imports,
    "",
    "export const remarkPlugins = {",
    ...remarkDefinitions,
    "}",
    "",
    "export const rehypePlugins = {",
    ...rehypeDefinitions,
    "}",
    "",
    `export const highlight = ${highlighter}`
  ].join("\n");
};
function processUnistPlugins(plugins) {
  const imports = [];
  const definitions = [];
  Object.entries(plugins).forEach(([name, plugin]) => {
    imports.push(`import ${pascalCase(name)} from '${name}'`);
    if (Object.keys(plugin).length) {
      definitions.push(`  '${name}': { instance: ${pascalCase(name)}, options: ${JSON.stringify(plugin)} },`);
    } else {
      definitions.push(`  '${name}': { instance: ${pascalCase(name)} },`);
    }
  });
  return { imports, definitions };
}

const registerMDCSlotTransformer = (resolver) => {
  extendViteConfig((config) => {
    const compilerOptions = config.vue.template.compilerOptions;
    compilerOptions.nodeTransforms = [
      function viteMDCSlot(node, context) {
        if (node.tag === "MDCSlot") {
          const transform = context.ssr ? context.nodeTransforms.find((nt) => nt.name === "ssrTransformSlotOutlet") : context.nodeTransforms.find((nt) => nt.name === "transformSlotOutlet");
          return () => {
            node.tag = "slot";
            node.type = 1;
            node.tagType = 2;
            transform?.(node, context);
            const codegen = context.ssr ? node.ssrCodegenNode : node.codegenNode;
            codegen.callee = context.ssr ? "_ssrRenderMDCSlot" : "_renderMDCSlot";
            const importExp = context.ssr ? "{ ssrRenderSlot as _ssrRenderMDCSlot }" : "{ renderSlot as _renderMDCSlot }";
            if (!context.imports.some((i) => String(i.exp) === importExp)) {
              context.imports.push({
                exp: importExp,
                path: resolver.resolve(`./runtime/utils/${context.ssr ? "ssrSlot" : "slot"}`)
              });
            }
          };
        }
        if (context.nodeTransforms[0].name !== "viteMDCSlot") {
          const index = context.nodeTransforms.findIndex((f) => f.name === "viteMDCSlot");
          const nt = context.nodeTransforms.splice(index, 1);
          context.nodeTransforms.unshift(nt[0]);
        }
      }
    ];
  });
};

const module = defineNuxtModule({
  meta: {
    name: "@nuxtjs/mdc",
    configKey: "mdc"
  },
  // Default configuration options of the Nuxt module
  defaults: {
    remarkPlugins: {},
    rehypePlugins: {},
    highlight: false,
    headings: {
      anchorLinks: {
        h1: false,
        h2: true,
        h3: true,
        h4: true,
        h5: false,
        h6: false
      }
    },
    components: {
      prose: true,
      map: {}
    }
  },
  async setup(options, nuxt) {
    const resolver = createResolver(import.meta.url);
    nuxt.options.runtimeConfig.public.mdc = defu(nuxt.options.runtimeConfig.public.mdc, {
      components: {
        prose: options.components.prose,
        map: options.components.map
      },
      headings: options.headings
    });
    nuxt.options.runtimeConfig.mdc = defu(nuxt.options.runtimeConfig.mdc, {
      highlight: options.highlight ? {
        theme: options.highlight.theme,
        preload: options.highlight.preload,
        wrapperStyle: options.highlight.wrapperStyle
      } : {}
    });
    nuxt.hook("vite:extendConfig", (viteConfig) => {
      viteConfig.optimizeDeps?.include?.push(
        "is-buffer",
        "debug",
        "flat",
        "node-emoji",
        "extend",
        "hast-util-raw"
      );
    });
    const { dst: templatePath } = addTemplate({ filename: "mdc-imports.mjs", getContents: mdcImportTemplate, options, write: true });
    nuxt.options.alias["#mdc-imports"] = process.env.NODE_ENV === "development" ? pathToFileURL(templatePath).href : templatePath;
    nuxt.options.nitro.alias = nuxt.options.nitro.alias || {};
    nuxt.options.nitro.alias["#mdc-imports"] = nuxt.options.alias["#mdc-imports"];
    addComponent({ name: "MDC", filePath: resolver.resolve("./runtime/components/MDC") });
    addComponent({ name: "MDCRenderer", filePath: resolver.resolve("./runtime/components/MDCRenderer") });
    addComponent({ name: "MDCSlot", filePath: resolver.resolve("./runtime/components/MDCSlot") });
    addImports({ from: resolver.resolve("./runtime/utils/node"), name: "flatUnwrap", as: "unwrapSlot" });
    if (options.components?.prose) {
      addComponentsDir({
        path: resolver.resolve("./runtime/components/prose"),
        pathPrefix: false,
        prefix: "",
        global: true
      });
    }
    if (options.highlight) {
      nuxt.options.nitro.experimental = nuxt.options.nitro.experimental || {};
      nuxt.options.nitro.experimental.wasm = true;
      addServerHandler({ route: "/api/_mdc/highlight", handler: resolver.resolve("./runtime/shiki/event-handler") });
    }
    extendViteConfig((config) => {
      config.optimizeDeps = config.optimizeDeps || {};
      config.optimizeDeps.exclude = config.optimizeDeps.exclude || [];
      config.optimizeDeps.exclude.push("@nuxtjs/mdc");
    });
    const _layers = [...nuxt.options._layers].reverse();
    for (const layer of _layers) {
      const srcDir = layer.config.srcDir;
      const globalComponents = resolver.resolve(srcDir, "components/mdc");
      const dirStat = await fs.promises.stat(globalComponents).catch(() => null);
      if (dirStat && dirStat.isDirectory()) {
        nuxt.hook("components:dirs", (dirs) => {
          dirs.unshift({
            path: globalComponents,
            global: true,
            pathPrefix: false,
            prefix: ""
          });
        });
      }
    }
    registerMDCSlotTransformer(resolver);
  }
});

export { module as default };
